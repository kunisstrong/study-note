# 重点

刻意练习 + 一万小时定律 = 精通一项技能

1. PV操作（也是难点）

# 系统概述

## 操作系统的概念及功能

操作系统对计算机资源进行调度与分配资源

结构（自下而上）：硬件（裸机）— 操作系统 — 软件 — 用户

操作系统实现了对硬件的封装拓展，让上层可以更方便的使用硬件的功能

## 操作系统的特征

### 并发 

并发：两个程序同时运行，宏观上是同一时间一起运行，微观上是cpu一会处理这个一会处理那个

并行：两个程序真正意义上的同时运行，需要多核cpu

### 共享 

两个应用程序同时访问系统资源

互斥共享方式：同一时间只能有一个进程访问系统资源，如qq与微信同一时间只能有一个程序使用摄像头

同时访问方式：同一时间可以有多个进程访问系统资源，如qq与微信同时给别人发送文件，可能是宏观上同时访问，微观上并发访问，又如打英雄联盟的同时听qq音乐，播放器会同时播放两个进程的声音

**tips：**

1. 并发与共享是操作系统最基本的特征
2. 并发与共享两者互为存在条件

### 虚拟（第一遍不是很懂，需要着重看）

空分复用技术（如虚拟存储器技术）

时分复用技术（如虚拟处理器）

如果失去并发性，那么也就用不上虚拟性

### 异步

多个进程同时运行，肯定会出现想要使用同一个系统资源的时候，比如摄像头或者打印机，这时候一个在使用，其他的进程需要等待，所以所有进程的运行都是走走停停的，这就是异步

### 重要考点

1. 并发与并行的区别：前者是多个进程交互被执行，后者是同时被cpu执行（多核cpu）
2. 并发与共享互为存在条件
3. 没有并发和共享，就谈不上虚拟和异步，所以说并发与共享是操作系统最基础的特性

## 操作系统的发展与分类

### 手工操作阶段

人们放纸袋的时间相较于计算机cpu的处理速度慢非常多

缺点：人机速度矛盾，人慢，计算机快

### 单道批处理程序

将程序放到磁盘中，第二个程序必须等第一个程序处理完之后执行，导致io工作时，cpu是空闲的，cpu工作时，io是空闲的

优点：解决了人机速度矛盾

缺点：资源利用率很低，各部分不能同时工作

### 多道批处理程序

第一个程序走到cpu处理时，io去读取第二个程序，第一个程序输出结果的时候，cpu去运算第二个程序

优点：资源利用率高，多道程序并发执行

缺点：不能人机交互，也就是不能debug

### 分时操作系统

计算机会以时间片的为单位轮流为用户、作业服务。

优点：解决了人机交互

缺点：不能处理紧急任务

### 实时操作系统

操作系统可以接受默写信号，就会紧急优先的处理该程序。

1. 硬实时操作系统：必须在规定时间内完成任务（导弹控制系统、自动驾驶）
2. 软实时操作系统：可以偶尔违反（12306）

优点：能够处理紧急任务

## 操作系统的运行机制

### 程序

1. 内核程序：
2. 应用程序：

### 指令

cpu能看懂的二进制代码，就是高级编程语言，被编译后的二进制代码

特权指令：当cpu处于内核态的时候才会执行

非特权指令：cpu处于内核态与用户态的时候都会执行

### 状态

cpu执行二进制的指令中，有特权指令与非特权指令，特权指令只能在执行内核程序的时候才能被执行，cpu可以区分哪些指令时特权指令，但是它怎么区分现在执行的内核程序还是应用程序呢，这是因为在cpu中有个寄存器，它用二进制代码记录着cpu的两种状态：内核态与用户态

内核态（核心态、管态）：可以执行特权指令

用户态（目态）：不可以执行特权指令

### 如何变态

内核态 -> 用户态：用一条特权指令把PSW的标志位设置为"用户态"

用户态 -> 内核态：由中断引起，硬件自动完成

### 中断与异常

#### 广义的中断

中断的结果是 cpu切换成内核态，也就是操作系统内核夺得cpu的使用权。

中断技术是操作系统并发特性的基础，因为没有中断cpu就会一直执行一个应用程序。

#### 中断

**内中断（异常）：**

与当前执行的指令有关，cpu内部发出中断指令。如：陷入指令（应用程序要使用系统服务）、故障、终止。

**外中断（中断）：**

与当前执行的指令无关，cpu外部发出中断指令（时钟中断、IO中断）。

#### 中断的基本实现原理

1. 发现中断，内中断（异常）：在执行指令的时候就会检查是否有异常发生。

外中断（中断）：在每条指令执行的末尾，就会检查是否有外部中断需要处理。

1. 找到对应的中断程序，使用"中断向量表"实现。

### 系统调用

操作系统向上提供系统服务，让上层程序可以使用内核服务。

#### 系统调用与库函数的区别

库函数是高级编程语言中内置库，开发者可以调用这些函数进行开发，有的库函数会调用系统调用。

系统调用比库函数更加底层。

## 操作系统体系结构

### 大内核、宏内核、单内核

将操作系统的主要功能都放在内核（时钟管理、中断处理、原语（一旦开始就不能停止）、进程管理、存储管理、设备管理）

优点：性能高，应用程序想要使用进程管理等服务时不用频繁切换 cpu状态（核心态与用户态）

缺点：代码混乱，难以维护

### 微内核

只将操作系统的主要功能放在内核（时钟管理、中断处理、原语），次要功能放在用户态执行（进程管理、存储管理、设备管理）

优点：代码清晰，便于维护

缺点：性能低，要经常切换cpu状态



## 操作系统引导

1. cpu从主存的特定位置，取指令，执行ROM中的引导程序（硬件自检，再开机）
2. 将磁盘的第一块—主引导记录读入内存，执行磁盘引导程序，读取分区表
3. 从活动次分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序
4. 从根目录下找到完整的操作系统初始化程序（即 启动管理器）并执行，完成“开机”的一系列动作

# 进程与线程

## 进程的概念、组成、特征

### 概念

程序：就是一堆静态代码，如QQ.exe，点击会产生一个qq进程

进程：点开程序后，就会开启一个进程，一个程序可以开启若干个进程。每个进程都有独一无二的id

操作系统对进程进行管理工作所需的所有信息都在PCB中

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/38472487/1692840730613-4e3760df-cc66-4bf1-892e-e9409a80e18e.jpeg)

### 组成

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/38472487/1692840732326-88304bef-3be9-4531-9aa5-c150525d088f.jpeg)

程序段与数据段是给自己用的，PCB是给操作系统做管理用的

PCB、程序段、数据段组成了进程实体

进程是进程实体的运行状态，是操作系统资源分配与调度的基本单位

注意，PCB是进程存在的唯一标志

### 特性

动态性是进程最近本的特性

异步性会导致并发程序执行结果的不确定性

## 进程的状态与转换、进程组织

### 进程状态与转换

创建态（新建态）：进程正在被创建，操作系统为进程分配资源，初始化PCB

就绪态：进程处于随时可以被cpu运行的状态，除了处理机其他都准备就绪

运行态：进程处于被cpu运行的状态，

阻塞态（等待态）：进程需要使用系统调用，但是要使用的系统服务正在忙，就会进入阻塞态，当要用的系统服务空闲了，改进程就会从阻塞态进入就绪态

终止态（结束态）：进程正在从系统撤销，操作系统会回收分配给进程的资源，撤销PCB

tips：

1. 时钟中断会强迫进程从运行态转换为就绪态
2. 进程不会从阻塞态直接转换成运行态，也不会从就绪态直接转换成阻塞态，
3. 进程从运行态转换成阻塞态是进程的主动行为，从阻塞态到就绪态是被动行为
4. 进程PCB中会有一个变量state记录进程的状态
5. 并且拥有相同状态的进程，操作系统会将其PCB统一组织起来

### 进程的组织

操作系统会将状态相同的进程进行统一管理，有两种管理方式

#### 链式方式：

操作系统会将不同状态的进程的PCB分为多个队列，操作系统持有各个队列的指针。

有的操作系统会将阻塞态的进程进行细分，如等待打印机的一个队列，等待磁盘的一个队列。

#### 索引方式：

操作系统会将不同状态的进程的PCB分为索引表，操作系统持有各个索引的指针。

#### tips：

1. 操作系统大多使用链式方式

## 进程的控制

进程的控制本质上就是控制进程转换状态，控制进程转换状态时使用原语实现的，因为原语具有原子性（一旦执行就不能停止，直到全部执行完毕）

进程状态的转换至少有两个步骤：

1. 将进程PCB中的state变量的值改变
2. 将PCB从原来的队列中放到转换后的队列中

两个步骤必须执行完才能保持进程信息的一致性

### 原语怎么实现原子性

原语通过"关中断"与"开中断"两个特权指令实现原子性

原理：cpu在执行指令的时候，每执行一句就会检查是否有外中断指令，如果有就会去执行中断程序。但是执行完"关中断"指令后，就算检查到外中断指令，也不会去执行中断程序，直到执行完"开中断"指令

### 进程控制相关的原语

#### 创建进程：

1. 创建空白的PCB
2. 为进程分配资源
3. 初始化PCB
4. 将PCB插入到就绪队列

#### 销毁进程：

1. 从PCB集合中找到对应进程PCB
2. 若进程处于运行态，就立刻停止该进程
3. 终止其进程的所有子进程
4. 回收将该进程的资源，并将资源归还给父进程或者操作系统
5. 删除PCB

#### 阻塞原语：

1. 找到阻塞进程对应的PCB
2. 保护进程现场，将PCB的state转换为阻塞态，暂停停止进程执行
3. 将PCB插入到阻塞队列

#### 唤醒原语：

1. 在队列中找到对应PCB
2. 将PCB从等待队列中删除，设置进程为就绪态
3. 将PCB插入到就绪队列

#### 切换原语：

1. 将运行环境信息存入PCB
2. PCB引入对应的队列
3. 选择另一个进程执行，并更新PCB
4. 根据PCB恢复新进程所需的运行环境



## 进程通信

三种通信的方式：

1. 共享存储
2. 消息传递
3. 管道通信

### 共享存储

两种共享存储通信的方式：

1. 基于存储区的共享方式
2. 基于数据结构的共享方式

#### 基于存储区的共享

操作系统分配一块空间，各进程可以随意的同步互斥的进行读存（同一时间只能有一个进程操作共享空间），这中共享方式灵活性高，速度很快，属于高级通信方式

#### 基于数据结构的共享

共享空间只能存储特定的数据结构，如：长度为10的int数组。这种方式灵活性低，速度慢，是低级通信方式

### 消息传递

两种方式：

1. 直接通信方式
2. 间接通信方式

#### 直接通信方式

操作系统内核中存着各进程的PCB，每个进程的PCB中都有各自的消息队列，用于存储通信的数据。

举例：进程a给进程b发送数据：

1. 进程a会先触发发送原语send(a, msg)
2. 操作系统将数据放到对应进程的PCB的消息队列中
3. 进程b触发接收原语receice(a, &msg)
4. 操作系统将b进程的PCB的消息列中，将a发送过来的数据放在进程b的内存中

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/38472487/1693275642188-4cecf66d-6667-48d5-9784-5e9ec5b42cb5.jpeg)

#### 间接通信方式

以“信箱”作为中间实体进程消息传递，操作系统内核中有“信箱”

举例：进程a给进程b发送数据：

1. 进程a触发发送原语，将数据存到对应信箱
2. 进程b触发接收原语，将对应信箱中的对应数据取出来









### 管道通信

“管道”是一种特殊的共享文件（循环队列），又名pipe文件。就是在内存中开辟一块大小固定的内存缓存区

与共享存储的区别：共享存储可以随意存，随意取，而管道通信只能先进先出



一个管道只能实现半双工通信，要想同一时间双向通信，需要建立两个通道

在考试中，管道是可以多个进程进行写的操作，只能一个进程读数据

但是在实际中，这取决与操作系统是怎么样设计的，如linux，就是允许多个进程写，多个进程读，只不过各个读进程要按顺序轮流读数据。

## 线程的概念

进程是操作系统进行资源分配的单位

线程是操作系统调度的基本单位

线程的出现让一个应用的不同功能可以同时进行，如qq的视频与发送文件

没有线程的时候，切换进程会切换运行环境，系统开销大，有了线程，同一进程中的线程切换不需要切换运行环境，系统开销低（应该是指的是cpu的运行环境）

## 线程的实现方式与多线程

### 用户级线程

用于早期没有线程的操作系统，程序员使用线程库，操作系统感知不到线程的存在，切换线程不需要cpu切换状态

优点：用户级线程的切换在用户空间即可完成，不需要切换至内核态，线程管理开销小，效率高

缺点：其中一个线程阻塞了，整个进程都会被阻塞，并发度不高。尽管在多核cpu中执行，同一进程的多个线程不能并行运行

### 内核级线程

现代操作系统大多都支持线程，操作系统能感知到线程的存在，切换线程需要cpu处于内核态

优点：当一个线程阻塞了，其他线程依旧可以继续运行，并发能力强。多个线程能够在多核cpu中并行执行

缺点：一个用户进程会占用多个内核线程，线程的切换是由操作系统完成，cpu需要切换至内核态，线程管理成本高开销大

### 多线程模型

#### 一对一模型

一个用户及线程对应一个内核级线程

优点：多个线程可以在多核cpu中并行运行，并发度高

缺点：线程切换需要cpu处于内核态，系统管理成本高，开销大

#### 多对一模型

多个用户级线程对应一个内核级线程

优点：线程切换在用户态就可以，线程管理开销小，效率高

缺点：多线程不能在多核cpu中并行运行，并发度低。一个线程阻塞，其他线程会阻塞

#### 多对多模型

n个用户级线程对应m个内核级线程（n > m）

集两家之长

## 线程的状态与切换

现在一般只关注三个状态：就绪态、运行态、阻塞态

切换状态与进程相似

线程与进程相似，有类似与PCB的TCB保存线程信息

多个TCB会组成线程表，线程可以根据不同的条件组成不同的线程表，如：同一进程、同一状态

## 调度的概念、层次

### 概念

当系统资源有限，但又有很多任务要处理的情况下，每个进程执行的先后顺序会由一个或者多个规则决定，这就是调度问题

### 高级调度（作业调度）

发生频率低

当又多个作业要执行，但是内存不够时，会有作业后备队列保存作业，并按照一定的算法，将作业加载到内存，并创建进程。每个作业只调入一次，调出一次。调入时创建PCB，调出时撤销PCB

### 低级调度（进程调度）

发生频率高

按照某种策略在就绪队列中选取一个进程，交由处理机处理。

进程调度是操作系统最基本的一种调度

### 中级调度（内存调度）

发生频率中

如果内存满了。操作系统会将一些进程放到外存中，然后将对应进程的PCB放入挂起队列，当内存有空间了，再将挂起队列中的进程加载到内存。这就是切换软件，有时候切换的快，有时候切换的慢的原因

### 七状态模型

加两个状态：就绪挂起、阻塞挂起

就绪态 -> 就绪挂起

阻塞态 -> 阻塞挂起

阻塞挂起 -> 就绪挂起

创建态 -> 就绪挂起

运行态 -> 就绪挂起

## 进程调度的时机、切换与过程、方法

### 进程调度的时机

进程主动（执行完毕），进程被动（分配的时间片到时间了）

不能中断进程的几种情况：

1. 执行中断程序
2. 执行原语
3. 进程在操作系统内核临界区

进程在内核临界区不可以进行进程的调度与切换，因为处于临界区的进程在访问资源的时候会将资源锁住，只能自己使用，如访问就绪队列，接续队列被锁住，就调度与切换不了进程了。

处于普通的临界区可以进行调度与切换，如使用打印机，这不影响cpu取运行其他进程

### 进程调度的方式

#### 非剥夺调度方式（非抢占式调度）

只能进程自己主动停止执行（进程执行完毕、主动进入阻塞队列），即便有非常紧急的任务，也只能等进程主动让出cpu资源

实现简单，系统开销小但无法及时处理紧急任务。适用于早期的批处理系统。

#### 剥夺调度方式（抢占式调度）

如果有更紧急的进程需要使用处理机，会立即停止处理当前进程，去执行紧急的进程。

可以优先处理紧急进程，可以实现时间片轮流执行的功能（通过时钟中断），适用于分时操作系统、实时操作系统。

### 进程的切换与过程

进程切换的两个步骤

1. 保存当前进程的信息至PCB
2. 还原新进程的运行环境

进程调度与切换是有代价的，并不是切换频率越高，并发度越好。

## 调度程序与闲逛线程

### 调度程序

负责进程调度的

对于不支持内核线程的操作系统，调度程序的处理对象是进程

对于不支持内核线程的操作系统，调度程序的处理对象是线程

### 闲逛线程

当处理机没有进程需要处理，cpu就会把闲逛线程搬出来执行

特点：

1. 能耗低
2. 优先级最低
3. 可以是0地址指令，占一个完整的指令周期（指令周期某位例行检查中断）

## 调度算法的评价指标

五个指标：

1. cpu利用率
2. 系统吞吐量
3. 等待时间
4. 响应时间
5. 周转时间

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/38472487/1693446135620-0a0d84e8-5b79-4dd7-a31d-39d582bc71fa.jpeg)

## 调度算法

### 先来先服务算法（FCFS）

#### 算法思想

从公平的角度出发，类似于排队买奶茶

#### 算法规则

按照作业、进程到达的顺序执行

#### 用于作业、进程调度

用于作业调度时，考虑的是哪个作业先达到后备队列

用于进程调度时，考虑的是哪个进程先进入就绪队列

#### 是否可以抢占

非抢占式

#### 优缺点

优点：公平，算法实现简单

缺点：排在长作业（进程）后面的短作业（进程）需要等待很长时间，带权周期大（周转时间 / 实际运行时间），对短作业来说用户体验不好。即：FCFS算法对长作业有利，对短作业不利

#### 是否会导致饥饿（某作业、进程长时间得不到服务）

不会

### 短作业优先

#### 算法思想

追求最少的平均等待、平均周转、平均带权周转时间

#### 算法规则

最短的作业、进程优先得到服务

#### 用于作业、进程调度

用于作业叫做短作业优先，即SJF

用于进程叫做短进程优先，即SPF

#### 是否可以抢占

可以是非抢占式的，即等作业、进程执行完才会发生调度

也可以是抢占式的，叫做最短剩余时间算法，即有进程进入就绪队列，或者有进程执行完毕，都会执行调度，比较剩余执行时间决定谁被服务

#### 优缺点

优点：“最短的”平均等待、周转、带权周转时间

缺点：对短作业有利，对长作业不利；可能会使长作业长时间得不到服务，造成饥饿。作业时长是由用户决定的，可能做不到真正的短作业优先

#### 是否会导致饥饿（某作业、进程长时间得不到服务）

会，并且如果有源源不断的短作业、进程进入到来，可能使长进程一直得不到服务，造成饿死的现象

### 高响应比优先

#### 算法思想

综合考虑 作业、进程的等待时间与要求服务时间

#### 算法规则

当作业、进程主动执行完毕，会发生调度，根据相应比（响应比 = (等待时间 + 要求服务时间)  / 要求服务时间），高响应比的先被服务

#### 用于作业、进程调度

可以用与作业，也可用于进程调度

#### 是否可以抢占

不可以抢占，只有作业、进程主动放弃处理机，才会发生调度，才会计算响应比

#### 优缺点

综合考虑了等待时间与运行时间

等待时间相同，要求服务时间短的优先（SJF优点）

要求服务时间相同，等待时间长的优先（FCFS的优点）

对于长作业来说，随着等待时间越来越长，响应比会越来越高，从而避免了长作业饥饿的情况

#### 是否会导致饥饿（某作业、进程长时间得不到服务）

否

### 时间片轮转

#### 算法思想

公平的，轮流的为每个进程服务，确保每个进程在一定的时间间隔内都得到响应

#### 算法规则

按照各进程进入就绪队列的顺序，轮流的让各个进程执行一个时间片，若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放入就绪队列

#### 用于作业、进程调度

用于进程调度（只有作业放入内存建立了响应的进程后，才能被分配处理机）

#### 是否可以抢占

抢占式。若进程在时间片内没有运行完，就会被剥夺处理机使用权，放回就绪队列。由时钟装置发出时钟中断来通知cpu时间片时间已到

#### 优缺点

优点：公平，响应快，适用于分时操作系统

缺点：频繁切换进程，有一定的开销。无法处理紧急任务

#### 是否会导致饥饿（某作业、进程长时间得不到服务）

不会

#### 补充

时间片太大会造成什么影响：会退化成先来先服务算法，对长作业有利，短作业不利

时间片太短会造成什么影响：进程调度、切换是由时间代价的（保存、恢复运行环境），时间片太小，系统会频繁切换进程，大量时间用在切换进程上，导致实际用于进程执行的笔记减少。

### 优先级调度算法

#### 算法思想

随着计算机的发展，特别是实时操作系统的到来，越来越多的场景需要处理紧急任务

#### 算法规则

调度是选择优先级最高的作业、进程

#### 用于作业、进程调度

作业、进程都可以。

作业是从后备队列加载到内存

进程是从就绪队列到运行队列

甚至还可以用于I/O调度

#### 是否可以抢占

可以是抢占，也可以是非抢占

非抢占只有进程主动放弃处理机时才会调度

抢占式在就绪队列发生改变时也会发生调度

#### 优缺点

优点：可以处理紧急任务

缺点：如果一直由高优先级的进程进入就绪队列，会造成低优先级进程饥饿

#### 是否会导致饥饿（某作业、进程长时间得不到服务）

会

#### 补充

可以分为静态优先级与动态优先级

静态优先级：一旦确定就不会改变，优先级的确定通常会根据一下几种策略

1. 系统进程优先于用户进程
2. 前台进程优于后台进程
3. I/O繁忙型进程优于与cpu繁忙型进程

动态优先级：优先级会实时的改变，通常会根据一下几个策略进程动态改变

1. 长时间处于就绪队列的进程优先级会适当增高
2. 长时间占用处理机的进程优先级会适当降低
3. 进程频繁进行I/O操作，优先级适当提高

### 多级反馈队列调度算法

#### 算法思想

对其他调度算法这种权衡

#### 算法规则

1. 设置多级就绪队列，优先级从从高到低，时间片由小到大
2. 刚到达就绪队列的进程在第一级队列，通过第一级时间片后，放入二级队列，以此类推。如果已经在最后一级队列了就插入到队列后方。
3. 因为是抢占式的，所以只要由新的进程达到，就会立即去执行新进程。

#### 用于作业、进程调度

用于进程调度

#### 是否可以抢占

抢占式的

也可能是非抢占式的，但是大多数都是抢占式的

#### 优缺点

优点：非常牛逼666

#### 是否会导致饥饿（某作业、进程长时间得不到服务）

会，如果由远远不断短进程进入队列，在次级队列中的进程会饥饿

### 多级队列调度算法

设置多级进程队列，每个队列装不同的类型的进程，并且优先级不同，如：

一级队列：系统进程（如内存管理进程）

二级队列：交互性进程（游戏、打字）

三级进程：批处理进程（AI模型训练、视频特效渲染）

队列之间课采用固定优先级，或者时间片划分

固定优先级：高优先级队列空时，低优先级才能被服务

时间片划分：如三个时间片分配时间分别为50% 40% 10%

也可以是其他的某种规则

## 进程同步、进程互斥

### 进程同步

两个及两个以上的进程并发时，有些进程需要按照一定顺序执行，如进程的管道通信，写进程一定要在读进程前面。这样的顺序就是进程同步

### 进程互斥

一个时间段只允许一个进程访问的资源叫做临界资源。

对临界资源的互斥访问，可以在逻辑上分为四个部分：

1. 进入区：检查是否可以进入临界区，然后上锁
2. 临界区（临界段）：访问临界资源
3. 退出区：解锁
4. 剩余区

需要遵循的原则：

1. 空闲让进：临界区空闲，允许进城访问
2. 忙则等待：临界区正在被访问，其他要访问的进程需要等待
3. 有限等待：要在有限的时间内访问临界区，防止出现饥饿
4. 让权等待：进入不了临界区的进程，要释放处理机，防止忙等

## *信号量机制

1. 整型信号量
2. 记录性信号量

信号量就是一个变量，可以是整型信号量，如计算机连接一个打印机，就有一个打印机的变量，值为一，也可以是复杂一些的记录性信号量

我们可以通过`wait(S)`与`signal(s)`原语操作信号量，这两个原语也就是PV操作

### 整型信号量

`wait(S)`也就是`P`操作，就是进入区，进程进入临界区，申请资源

`signal(S)`也就是`V`操作，退出区，进程释放资源 

存在的问题（**常考**）：不满足“让权等待”原则，第二个申请资源的进程会一直等待，出现“忙等”

### 记录型信号量（ 超高频出题点）

会有一个变量记录资源的信息，如value记录还有多少资源，process继续等待使用资源的进程

还是通过使用`PV`操作申请与释放资源

`wait(S)，即P(S)操作`：让`value--`，当资源数为0时，执行`block`原语，使进程变为阻塞态，进入阻塞队列，并且放入`process`队列，等有资源的时候唤醒进程

`signal(s)，即V(S)操作`：让`value++`，然后执行`wakeup`原语，在`process`唤醒一个进程，让该进程从阻塞队列进入就绪队列，然后使用资源

什么情况会执行`block`与`wakeup`这两个原语：

当资源为0时，有进程申请资源会执行`block`

当有进程释放资源，但资源`value <= 0`，也就是`process`队列不为空的时候，执行wakeup

## *用信号量实现进程互斥、同步、前驱关系 

### 进程互斥

`semaphore mutsx 1;`就表示定义一个资源的记录型信号量，不会出现“忙等”

### 进程同步

概念：要让进程按要求有序的执行。例如：两个进程异步执行，其中一个进程代码要在另一个进程的代码执行后再执行。

**口诀：前V后P**

1. 先执行的代码后面执行V
2. 后执行的代码前面执行P 

### 前驱关系

跟实现进程同步一样，就是多级同步

### 个人理解

申请资源就是P原语

释放资源就是V原语

进程互斥是pv操作在一个进程上

同步是pv操作在两个进程上

## *生产者—消费者问题

- mutex：实现缓冲区的互斥操作
- empty：空闲缓冲区的数量
- full：产品的数量

### 生产者

生产一个产品

消耗空闲缓存区：`P(empty)`

对缓存区上锁：`P(mutex)`

把产品放到缓存区

增加产品：`V(fulll)`

对缓存区解锁：`V(mutex)`

### 消费者

消耗产品：`P(full)`

对缓存区上锁：`P(mutex)`

从缓存区取走产品

增加空闲缓存区：`V(empty)`

对缓存区解锁：`V(mutex)`

使用产品

### 注意点

1. 实现互斥的P操作一定要在实现同步的P操作之后（生产者和消费者只要有一个满足就好）
2. 两个V操作可以互换

## *多生产者—多消费者

如两组生产者—消费者各自同时在一个缓冲区进行生产与消费

举例：爸爸生产苹果，妈妈生产橘子，儿子只吃苹果，女儿只吃橘子

涉及的变量

1. semaphore mute = 1;  用户盘子的互斥操作（缓冲区）
2. semaphore apple = 0; 盘子中的苹果数
3. semaphore orange = 0;  盘子中的橘子数
4. semaphore plate = 1; 盘子中还可以放几个水果

爸爸：

1. 生产苹果
2. P(plate)
3. P(mute)
4. 放入苹果
5. V(mute)
6. V(apple)

妈妈：

1. 生产橘子
2. P(plate)
3. P(mute)
4. 放入橘子
5. V(mute)
6. V(orange)

儿子：

1. P(apple)
2. P(mute)
3. 从盘子中取苹果
4. V(mute)
5. V(plate)
6. 吃苹果

女儿：

1. P(orange)
2. P(mute)
3. 从盘子中取橘子
4. V(mute)
5. V(plate)
6. 吃橘子

## *吸烟者问题

有三个吸烟者（消费者），一个提供材料的人（生产多个产品的生产者）。卷烟需要三个原料，三个吸烟者每人各有一个材料，剩下的两个由生产者提供。并且生产者提供材料的时候要让吸烟者轮流吸烟

**涉及的变量：**

1. offer1 = 0：吸烟者1需要的材料
2. offer2 = 0：吸烟者2需要的材料
3. offer3 = 0：吸烟者3需要的材料
4. finish = 0：抽烟是否完成
5. int i = 0：使用实现轮流抽烟

**生产者：**

```c
if(int == 0) {
    将组合1放桌上
        V(offer1);
}else if(int == 1) {
    将组合2放桌上
        V(offer2);
}else if(int == 2) {
    将组合3放桌上
        V(offer3);
}

i = (i + 1) % 3;
P(finish);
```

**消费者1：**

1. P(offer1)
2. 卷烟、抽烟
3. V(finish)

**消费者2：**

1. P(offer2)
2. 卷烟、抽烟
3. V(finish)

**消费者3：**

1. P(offer3)
2. 卷烟、抽烟
3. V(finish)

## *读者写者问题

1. 写者与写者、写者与读者都要互斥互斥访问文件
2. 读者与读者可以同时访问文件

**涉及变量：**

1. `rw`：用于实现对文件的互斥访问
2. `count`：实现读者可以同时访问文件
3. `mutex`：实现`count++` 与 `对文件上锁`一气呵成，防止两个读者进程死锁。如读者1 通过了`count == o`的`if`校验，还没有对文件上锁，也没有进行`count++`，这时读者2访问文件，通过了`count == 0`的`if`校验，并且对文件上了锁。这时再回到读者1，读者1就会被阻塞
4. `w`：用于防止不断由读进程进来，造成写进程饥饿

**writer：** 

1. P(w)
2. P(mutex)
3. 写内容
4. V(mutex)
5. V(w)

**reader：**

```c
P(w);
P(mutex);
if(count == 0) {
    P(rw);
}
count++;
V(mutex);
V(w);

// 读文件
P(mutex);
count--;
if(count == 0) {
    V(rw);
}
V(mutex);
```

## *哲学家进餐问题

例如：一张圆桌上有五个哲学家进程，哲学家只能干两件事情，思考与吃饭。吃饭的时候需要用两双筷子，但是每两个哲学家中间只有一双筷子。

因为哲学家吃饭的时候需要两个临界资源，所以要考虑死锁的情况

**涉及的变量：**

1. `mutex`：互斥的取筷子
2. `chopstick[5] = {1, 1 ,1, 1, 1}`

```c
P(mutex);
P(chopstick[i]);
P(chopstick[(i + 1) % 5]);
V(mutex);
// 吃饭
V(chopstick[i]);
V(chopstick[(i + 1) % 5]);
// 思考
```

## 管程

就是将同步互斥的代码进行封装，对外提供接口调用

可以用于解决进程的同步互斥问题，跟Java中的类差不多

1. 有共享数据，就是类中的数据
2. 对数据进程初始化的语句
3. 有访问数据的入口，就是函数方法（过程）

**管程的基础特征：**

1. 外部进程只能通过函数（方法）访问共享数据
2. 每次只允许一个进程在管程内执行函数方法（过程）

## 死锁的概念

### 死锁

各进程互相等待对手进程的资源，从而导致阻塞，无法向前推进的现象

只能处于阻塞态

至少两个进程

### 饥饿

长时间得不到想要的资源，某进程无法推进的现象。（如短进程优先，源源不断有短进程进来，长进程就一直得不到处理，长进程就会饥饿）

可能处于阻塞态与就绪态

可能只有一个进程

### 死循环

`while(true){}`：是被管理者的问题

可能处于运行态

可能只有一个进程

### 易考的知识点

1. 死锁和饥饿是操作系统要解决的问题
2. 死循环是开发者程序员要解决的

### 死锁产生的必要条件

#### 互斥条件：

各进程抢夺的资源是互斥的，不能同时使用

#### 不剥夺条件：

进程之间不能互相抢夺对方的资源，只能主动让出

#### 请求与保持条件：

进程已经持有至少一个资源，但是又提出了新的资源请求，而该资源被其他资源所占用，进程被阻塞，但又对自己持有的资源保持不妨

#### 循环等待条件：

每个人都在等待其他人的互斥资源，并且不会放下自己的资源

循环等待不一定会发生死锁，但死锁一定会发生循环等待

#### 总结

1. 各进程抢占的资源是互斥的
2. 并且不能从其他进程手中抢资源，只能等其他进程主动让出资源
3. 自己手里有资源，但是需要另外一个资源才能继续执行，而需要的资源在其他进程手中，从而造成阻塞
4. 每个进程都在等待其他进程手中的资源
5. 循环等待不一定会发生死锁，但死锁一定会发生循环等待

### 什么时候会发生死锁

对不可剥夺资源的不合理分配，就会造成死锁

### 死锁的处理策略

1. 预防死锁：至少破坏死锁产生的四个必要条件中的一个
2. 避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
3. 死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种操作接触死锁

## 预防死锁

只要破坏四个死锁产生的条件之一就可以预防死锁

### 破坏互斥条件

#### 实现

将临界资源变成可以共享访问的资源。通过SPOOling技术

#### 缺点

1. 有些资源不能变成共享资源

### 破坏不剥夺条件

#### 实现

策略一：在得不到资源的时候就释放资源

策略二：交由操作系统管理，想用的资源被别人占用的时候，根据优先级剥夺资源与分配资源。

#### 缺点

1. 实现起来困难
2. 有源源不断优先级高，并且需要使用该资源的进程进来，会造成饥饿
3. 反复的申请与释放资源，增加系统开销，降低系统吞吐量

### 破坏请求与保持条件

#### 实现

采用静态策略：必须将资源都收集完才能开始运行

#### 缺点

会造成资源利用率低，可能造成饥饿

### 破坏循环等待条件

#### 实现

给资源编号，进程只能从小编号向大编号资源申请

#### 缺点

1. 会造成资源浪费，资源利用率低
2. 不方便添加新设备
3. 用户编程麻烦

### 注：

1. 可以回头看看解决哲学家进餐解决死锁的方法用到了哪个

## *避免死锁（银行家算法）

### 安全序列

指系统按照这样得序列运行进程，每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态，反之则是不安全状态。

处于安全状态一定不会发生死锁。

处于不安全状态不一定会发生死锁，但是死锁一定处于不安全状态

### 银行家算法

#### 核心思想

在资源分配之前，判断分配之后系统会不会处于不安全状态，如果会处于则不这样分配

#### 题目涉及到变量

1. 最大资源需求（Max）
2. 已分配资源（Allocation）
3. 系统还可提供资源（Available）
4. 进程还需资源（Need）

#### 解法

利用123求出4，然后再用3 4判断是否为安全状态

## 死锁的检测和解除

### 死锁的检测

技巧：先看请求边

如果所有边都能消除，就不会出现死锁

### 死锁的解除

1. 资源剥夺法
2. 撤销进程法（终止进程法）
3. 进程回退法









































# 内存管理

## 内存的基础知识

### *内存

8位`8bit` = 1字节`1Byte`

需要熟练的计算二进制与十进制之间的转换

按字节编址：一个存储单元存储一个字节（1Byte）
按字编址

### *物理地址与逻辑地址

逻辑地址（相对地址）：将高级语法编译后代码的地址就是逻辑地址

物理地址（绝对地址）：就是内存的实际地址

### *从写程序到程序运行

1. 程序员写代码，有a b c三个模块
2. 经过编译，生成编译后的三个模块（机器语言，逻辑地址）
3. 链接，将编译后的代码放在一个模块（逻辑地址）
4. 转入，将模块装入内存中（物理地址）。重定向寄存器记录起始位置，为后面地址计算做准备

### 装入的三种方式

#### 绝对装入

在编译的时候，根据进程的起始位置，计算出数据要存储的正确的物理地址

灵活性很差，只适用单道程序环境

#### *静态重定位（可重定位装入）

在将作业装入内存的时候，进行重定位，重新计算跟地址相关的所有变量，如进程的起始地址为100，所有地址变量就都+100

#### *动态重定向（动态运行时装入）

在运行时，cpu运行时将所有地址+重定位寄存器的地址

需要重定位寄存器，他用来存储装入模块存放的起始位置

允许程序在内存中发生移动，因为地址是在运行时计算的，移动的时候将重定向寄存器中的值修正就行

### 链接的三种方式

#### 静态链接

将编译后就将所有模块链接到一起

#### 装入时动态链接

在装入时将模块链接到一起

#### 运行时动态链接

运行时将模块连接到一起

这样就能实现没有用到的模块就不用装入内存，提高内存利用率

## 内存管理的概念

1. 内存的分配的回收
2. 内存空间的扩充（实现虚拟化）
3. 地址转换（逻辑地址 —> 物理地址）
4. 内存保护：防止干扰其他进程

1. 1. 设上下限寄存器
   2. 利用重定向寄存器与界地址寄存器判断

## 覆盖与交换

### 覆盖技术

常用的模块放在固定区

不常用的放在覆盖区，用于不会同时运行的模块轮流使用

缺点：操作系统不知道模块结构，需要程序员自己声明，增加开发成本

在早期系统中使用，现在很少使用

### 交换技术

将内存中暂时不能运行的进程移到外存的对换区中

#### 磁盘

分为两个区域：对换区与文件区

对换区采用连续分配方式，IO速度比文件区快

文件区采用离散分配，空间利用率高

#### 换出什么进程

1. 阻塞中的进程
2. 优先级低的进程，为了防止饥饿，可结合在内存中驻留的时间

注：PCB常驻内存，不会被换出

#### 复习

高级调度：给作业分配内存，系统资源

中级调度：将外存对换区中的具备运行条件的进程装入内存

低级调度：将内存中就绪队列中的进程交给处理机运行

### 两者区别

1. 覆盖技术是针对同一个进程的
2. 交换技术是针对不同进程的

## 内存空间的分配—连续分配管理方式

### 单分区分配

内存上只能存在一个进程

#### 缺点

1. 存储利用率极低

### 固定分区分配

将内存其他固定分成不同的分区

#### 大小相等

每个分区大小相等

#### 大小不等

每个分区大小不等

#### 缺点

1. 存储利用率低

### 动态分区分配

在作业装入内存的时候再动态分配空间，需要多少分配多少

#### 如何记录分区

1. 空闲分区表：记录分区的分区号、起始位置，大小等信息
2. 空闲分区链：将空闲的分区用双向链表表示

#### 如何分配分区（原进程执行完， 有新的作业进来）

使用动态分区分配算法，后面详细讲

#### 如何分配与回收

先修改对应数据结构，再操作内存

#### 内部碎片

进程需要10MB，但被分配12MB的内存，就有2MB的内部碎片

固定分配会有内部碎片，再动态分区分配没有

#### 外部碎片

固定分配不会有外部碎片，动态分区分配有

整个内存有100MB，现有进程占用了98MB，这时就有2MB的外部碎片

可用紧凑技术来解决

## 动态分区分配算法

产生原因：有多个分区能满足新进程的需要，将进程分配给哪个分区

### 首次适应算法

#### 算法思想

找低地址并且能满足进程需要的分区

#### 具体实现

使用空闲分区表或空闲分区链，将分区从低地址到高地址进行排列

#### 优点



综合来看性能最好，算法开销小。回收分区后不用对空闲分区队列重新排序

#### 缺点

1. 小地址划分成很小的地址后，检索的时候每次都要重新检索一边，会增加时间成本

### 最佳适应算法

#### 算法思想

找容量最小并且能满足进程需要的分区 

#### 具体实现

使用空闲分区表或空闲分区链，将分区按容量递增排列

#### 优点

不用重新排序，会留下大分区满足大进程的需求

#### 缺点

1. 产生很多难以利用的小碎片
2. 算法开销大，需要频繁修改空闲分区队列

### 最坏适应算法

#### 算法思想

找容量最大的分区

#### 具体实现

使用空闲分区表或空闲分区链，将分区按容量递减排列

#### 优点

可以减少产生难以利用的小碎片

#### 缺点

1. 会有越来越多的小分区，如果来个大进程，无法满足需求
2. 算法开销大，需要频繁修改空闲分区队列

### 临近适应算法

#### 算法思想

对首次适应算法进行改变，不会每次都从头开始检索，是在上次满足条件的分区开始检索

#### 具体实现

使用空闲分区表或空闲分区链，将分区从低地址到高地址进行排列

如果是使用空闲分区链，要使用循环链表，不然会造成前面分区的空间浪费

#### 优点

1. 不用每次都从低地址开始检索，节约时间成本。
2. 算法开销小

#### 缺点

1. 会有越来越多的小分区，如果来个大进程，无法满足需求

## 内存空间的分配—非连续分配管理方式

### 基本分页存储管理

#### 什么是分页存储

将内存分为大小相等的分页，每个分页就是一个页框（页帧、内存块、物理块、物理页面），每个页框有一个编号，叫做页框号（页帧号、内存块号、物理块号、物理页面），页框号从0开始

将进程的逻辑地址空间也分为与页框大小相等的一个个部分，称为页或页面，每个页面也有编号，称为页号或者页面号

操作系统会为每个进程建立一张页表，页表记录着页面与页框之间的映射关系，页表放在PCB中（进程控制块）

1KB = 1^10Byte

1Mb = 1^20Byte

1GB = 1^30Byte

#### 求每个页框占多大内存

1. 求内存中一共多少页框，进而求出页框号的范围
2. 根据页框号的范围，求出每个页框号占多少位
3. 换算成字节

页号、页面号不占内存，类比数组

#### 存储整个页表需要多少内存

`页框占多少字节(总共有多少页框 + 1)`（因为从0开始）

j号页框在内存中的其实地址 = j * 内存块大小（j表示内存中的页框号）

#### 如何确定逻辑地址对应的页号，页内偏移量

页号 = 逻辑地址（进程总大小） /   页面长度，向下取整

业内偏移量 = 逻辑地址（进程总大小）%  页面长度

#### 如何实现逻辑地址转换成物理地址

已知页框是页框号，求页框的物理地址

需要知道三个条件

1. 页号
2. 起始地址（根据页框号查页表，用页框号 * 内存块大小）
3. 偏移量

#### 为何页面大小要取整数次幂

1. 逻辑地址的拆分更加迅速
2. 物理地址的计算更加迅速

#### 逻辑地址结构

如果有K位表示“业内偏移量”，则说明该系统中一个页面的大小是2^K个内存单元

如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2^M个页面

重要：(页面大小<—>页内偏移量位数）—> 逻辑地址结构

有的题目页面大小不是2的整数次幂，就得用原始得方法计算



页号 = 逻辑地址 / 页面长度（取触发得整数部分）

页内偏移量 = 逻辑地址 % 页面长度（取除法得余数部分）

#### 基本地址变换机构

用于实现逻辑地址到物理地址转换的一组硬件机构 

页表寄存器：存放页表的起始地址与页表长度

进程未被执行时，页表的起始地址与页表长度存放在PCB中，被执行时，就会拿出来放在页表寄存器

*页面大小为L，逻辑地址A到物理地址E的变换过程如下：

1. 根据逻辑地址求出页号P与页内偏移量W
2. 页号P跟寄存器中的页表长度M做比较，P >= M，则产生内中断（页号是从0开始，页表长度是从1开始，两者相等也会产生越界
3. 页表中页号P的页表项起始地址 = 页表起始地址 + P * 页表项长度

![img](https://cdn.nlark.com/yuque/0/2023/png/38472487/1694681056407-2b1280f5-f3a8-4b7c-9af8-e0219951f9fa.png)

#### *地址变换过程

1. 根据逻辑地址算出页号、页内偏移量
2. 页号的合法性检查（与页表长度对比）
3. 若页号合法，再根据页表起始地址、页号找到对应的页表项
4. 根据页表项中记录的内存块、页内偏移量 得到最终的物理地址
5. 访问物理内存对象的内存单元

#### 总结

1. 想要求指令在内存中的物理地址需要知道三个条件

1. 1. 页号
   2. 页内偏移量
   3. 指令在内存中的起始地址
   4. 其中页号是最重要的，知道页号就能求出页内偏移量与在内存中的起始地址

1. 逻辑地址结构

1. 1. 共32位
   2. 0~11位表示 业内偏移量 => 一个页大小2^12个内存单元
   3. 12~31位表示 页号 => 一共有2^20个页
   4. 有的题不是32位，类比着计算

1. 页表：用于记录页号与页框号对应关系

1. 1. 可以根据页号求出页框号（也就是在内存中的第几块）
   2. 进而求出在内存中的起始地址

1. 公式：b(内存块号)*L(内存块大小)+W(页内偏移量)
2. 页内偏移量占十位 = 页面大小为 1k（2^10 = 1024）

### 快表的地址变换机构

#### 什么是快表

快表，又称联想寄存器（TBL），是一种高速缓存。

用于存储cpu最近访问的页表项的副本，cpu访问缓存，比访问内存中的页表快得多。如Redis

内存中的页表成为慢表

RAM是内存

Cache是高速缓存

#### 引入快表之后，地址的变换过程

1. 先去快表中查找页号，命中直接去内存中找对应的内存块
2. 未命中，去慢表中找，也就是内存中的页表

例题：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构，访问一次快表耗时1us，访问一次内存耗时100us，若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少

答：`(1 + 100)*0.9 + (1 + 100 + 100)*0.1 = 111us`

注意：要是系统支持快表和慢表同时查找，答案就是

```
(1 + 100)*0.9 + (100 + 100)*0.1 = 110.9us
```

#### 局部性原理

时间局部性：如果执行了程序中的某段指令，那么不久之后这条指令很可能会被再次执行；如果某个数据被执行过，那么不久之后，这个数据很可能会被再次访问（因为程序中存在大量的循环）

空间局部性：一旦程序访问了某个存储单元，那么不久之后，其附近的存储单元很可能被访问（因为很多数据在内存中都是连续存放的）

### 两级页表

#### 单级页表存在什么问题？如何解决

存在的问题：

1. 需要较大的连续的内存空间，与离散存储理念相悖
2. 根据局部性原理，程序在一段时间可能只需要访问某几个特定页面就能运行，所以没必要让整个页表常驻内存

如何解决：

将大页表分为多个小页表，这是就需要另外一个表来记录每个小页表，这个记录的表称为页目录表，或外层页表，或顶层页表

每个小页表跟一个内存块大小相等，也就是`内存块大小(4KB) / 页表项大小(4B) = 2^12`



这是逻辑地址结构也需要发生变化，如：

![img](https://cdn.nlark.com/yuque/0/2023/png/38472487/1694852048055-3b7bcacb-146a-484b-8ee9-a28915207cd9.png)

#### 如何实现地址变换

将逻辑地址分为3部分，根据一级页表 -> 二级页表 -> 内存块

### q基本分段存储管理

与分页最大的区别就是—离散分配时所分配地址空间的基本单位不同

#### 什么是分段

按照自身逻辑关系划分成若干个段

逻辑地址结构由段号和段内地址组成

段号的位数决定了进程最多可以分成多少个段

段内偏移量决定了每个段的最大长度是多少

例如：若系统是按字节寻址

段号占16位，在该系统中，进程最多被分为2^16K个段

段内偏移量占16位，因此每个段最大的长度为2^16KB

#### 什么是段表

跟页表类似

记录了：段号、段长、基址

#### 如何实现地址变换



#### 从装入内存到执行

1. 作业装入内存，称之为进程，然后在PCB中将段表的信息（段表始址F、段表长度M）读入段表寄存器。段表结构（段号、段长C、基址B）
2. 开始运行进程中的某一段程序，根据逻辑地址（段号S、段内地址W），在段表寄存器中对应的段表项。S >= M段号越界，越界中断。F + S * 段表项长度
3. 因为每个段表项长度不一定一样（页表的每一项长度都是一样的），要检查 是否W > M，是则越界中断。
4. 最后根据基址B + 段内地址W找到内存中对应的代码段

#### 分段、分页管理的对比

页的信息是物理单位，是机械的将进程分为若干个长度相等的页。分页是为了离散存储，提高内存利用率。对用户不可见

段的信息是逻辑段位，是根据程序的逻辑将进程分为若干个长度不等的段。分段是为了更好的满足用户的需求，通常一个段包含着一组属于一个逻辑模块的信息。对用户可见

分页的用户进程地址空间是一维的

分段的用户进程地址空间是二维的

分段比分页更容易实现信息的共享与保护



不能修改的代码成为纯代码或可重入代码

### 段页式管理方式

#### 分页、分段管理方式中最大的优缺点

分页优点：内存利用率高，没有外部碎片，只有少量的内部碎片

分页缺点：不方便按照逻辑模块实现信息的共享和保护

分段优点：方便按照逻辑模块实现信息的共享和保护

分段缺点：如果段过大，分配连续的大内存很不方便。内存利用率低，会产生外部碎片

#### 分页、分段的结合—段页式管理方式

段页式的逻辑地址结构：段号、页号、页内偏移量

段号的位数决定了每个进程最多可以分为几个段

页号位数决定了每个段最大有多少页

页内偏移量决定了页面大小，也就是内存块大小是多少

#### 段表、页表

一个进程可能对应一个段表，多个页表

#### 如何实现地址变换

逻辑地址有段号、页号、页内地址

## 虚拟内存的基本概念

### 传统存储管理方式的特征、缺点

一次性：作业运行时必须将作业全都放入内存，大作业无法装入内存，就无法运行。有很多作业时也无法全都装入内存，降低并发性。

驻留性：作业一旦读入内存，就会一直主流在内存中，直到运行结束。事实上，在一个时间段内，只需要访问作业中的某些数据即可正常运行，这就导致内存中有大量的用不到的数据，浪费空间

### 局部性原理

时间局部性：在某一时间执行了某条指令，那不久后大概率会再次执行者条指令。因为程序中存在大量的循环

空间局部性：一旦程序访问了某个存储单元，在不久后，他附近的存储单元也大概率会被访问。因为很多数据在内存中都是连续存放的

### 虚拟内存的定义和特征

基于局部性原理，将很快要用到的数据放入内存，其他用不到先放在外存。如果所访问的内存不在内存时，操作系统会将所需数据放入内存。

1. 多次性：不需要一次性将作业全都加载到内存，用到什么数据就加载什么数据
2. 对换性：作业无需一直驻留在内存，允许换入、换出
3. 虚拟性：从逻辑上扩展空间，虽然实际的物理内存没有变大，但在用户的角度，内存变大了

### 如何实现虚拟内存技术

使用连续存储会非常难实现，需要使用离散存储

连续存储：单一分区存储、固定分区存储、动态分区存储

离散存储：基本分页存储、基本分段存储、基本段页存储

虚拟内存的实现：

1. 请求分页存储
2. 请求分段存储
3. 请求段页式存储

区别：在基本离散存储的基础上实现请求调页与页面置换功能

白话：用到的页就放入内存，内存空间不足就将用不到的放入外存。

## 请求分页管理方式

在基本分页的基础上做出拓展

1. 在程序执行的过程中，所需的信息不在内存，将信息从外存读入内存（请求调页功能）
2. 在内存空间不够时，将用不到的信息换出到外存（页面置换功能）

### 页表机制

页号、内存块好、状态位（是否在内存）、访问字段（最近被访问过几次）、修改位（页面调入内存后是否被修改过）、外存地址（页面在外存的位置）

### 缺页中断机构

作业被执行的时候，如果要访问的页不在内存，就将程序中断，放入阻塞队列，然后将缺的页调入内存，调页完成后唤醒，放入就绪队列 。如果内存没有空间，就会根据置换页面算法将对应的页面换出到外存，腾出空间

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/38472487/1695267331423-b7b3a030-a75f-416f-a53e-d983d55bae39.jpeg)

## 页面置换算法

### 最佳置换算法（OPT）

选择以后永久不会被访问的页，或者最长时间不被使用的页置换出去

缺页率 = 缺页中断 / 访问页面总次数

缺点：需要提前知道页面的访问序列，无法实现，进程在运行的时候才会知道下一个要执行哪个页面

### 先进先出置换算法（FIFO）

先进入内存的页面先被置换出去，维护一个队列

缺点：虽然算法简单，但是该算法与进程实际的运行规律不匹配，算法性能很差，有Belady异常

Belady异常：当为进程分配的物理块增多时，缺页的次数不减反增的异常现象

### 最近最久未使用置换算法（LRU）

选择最近且最久没有被使用的算法

缺点：虽然性能较好，是最接近最佳置换算法的算法。但是实现困难，需要硬件的支持

### 时钟置换算法（CLOCK）

选择最近未用的页面，维护一个循环队列，在页表项中添加一个表示最近是否被访问的标识，0是最近未访问过，1是最近访问过。

内存满的时候，开始在列表中检索，遇到标识为0的就被会置换出去。检索完页面就会把页面对应的页表项的标识符重置为0。

有可能所有页面的页表项标识符都是1，就需要扫描第二轮

是性能和算法开销比较均衡的算法

### 改进型时钟置换算法

在CLOCK算法的基础上，把是否被修改过这个元素考虑进去
设置两个标识是否最近访问过，是否被修改。如：（1， 1）表示最近被访问过，被修改过

淘汰的优先级：(0, 0) -> (0, 1) -> (1, 0) -> (1, 1)

第一轮：查找 0，0。不修改标识

第二轮：查找0，1。修改标识

第三轮：查找0，0。不修改标识

第四轮：查找0，1

最多检索4轮，普通的CLOCK算法最多检索两轮

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/38472487/1695361761400-4ae72084-efbf-4d5b-bcbd-b3c939a97048.jpeg)

## 页面分配策略

### 驻留集

定义：指请求分页存储管理中给进程分配的物理块的集合

有固定大小，也有可变大小的。

局部置换：只能在自己的驻留集中置换

全局置换：可以从其他进程的驻留集中置换出空间

固定大小的驻留集不能搭配全局置换，全局置换必然会改变驻留集的大小

### 页面分配、置换策略

固定分配局部置换：操作系统为进程分配固定的驻留集，页面置换只能在自己的驻留集里发生。缺点是很难在开始时确定分配给进程多大内存才合适。可以用过看进程的大小，以及，程序员给的参数

可变分配全局置换：操作系统给进程一个可变的驻留区，操作系统有一个空闲物理块，每当进程缺页，操作系统会优先将空闲物理块给进程，若已无空闲物理块，则会将其他进程的空闲的物理块给缺页的进程。只要进程发生缺页，就会获取新的物理块。缺点是被选中的进程驻留区变小，缺页率会提高

可变分配局部置换：操作系统给进程一个可变的驻留区，进程缺页从自己的驻留区发生置换操作。操作系统会根据驻留区的缺页率增加和减少驻留区的物理块



可变分配全局置换：只要缺页就会分配新的物理块

可变分配局部置换：根据缺页率动态的调整驻留区的大小

### 调入页面的时机

预调页策略：根据空间局部性原理（如果当前访问某个内存存储单元，不久后大概率会访问其相邻的内存单元）。每次调页的时候将周围的页一起调入内存。但是调的页大部分没有被用到，则会很低效。目前的预测成功率只有50%左右。所以一般都用在进程的首次调入

请求调页策略：进程运行期间发现缺页时才将所缺页面调入内存。由于每次缺页都要磁盘IO操作，因此IO开销很大

### 从何处调页

系统拥有足够的对换区空间：调入调出都在内存与对换区之间进行

系统缺少足够的对换区空间：对于不会修改的页，从文件取调入内存，因为不需要再调出到文件区。对于可能会被修改的页，换出时需要换出到对换区。

UNIX方式：首次加载是从文件区调入，运行过程中的调入调出都是在内存与对换区之间发生的

### 抖动（颠簸）现象

指某个页面频繁的被调入调出内存，原因是分配给进程的物理块太少

### 工作集

指某段时间内，进程实际访问页面的集合

一般来说，驻留集的大小大于工作集

# 文件管理

## 文件逻辑结构

### 无结构文件

文件内部的数据就是一系列二进程流和字符流。又称流式文件。如windows的`.txt`文件

### 有结构文件

由一组相似的记录组成。又称记录式文件。每条记录由若干个数据项组成。如：数据库表文件。根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录与可变长记录

#### 顺序文件

每一条记录在逻辑上是一个接一个顺序排列，记录可以是定长的也可以是可变长的。各个记录在物理上可以是顺序存储也可以是链式存储

根据记录是否按照关键字顺序排列还可分为

1. 串结构：记录不按照关键字顺序排列。通常是按时间排序
2. 顺序结构：记录按照关键字顺序排列

顺序存储定长记录可以实现随机存储，若再能保证记录的顺序存储，则可以快速检索（即根据关键字快速检索到数据）。可变长不可以

#### 索引文件

为了实现可变长记录文件也能随机存储。操作系统会维护一个索引表（定长记录的顺序表），一个表项对应一个记录

#### 索引顺序文件

一个表项对应一组记录

#### 多级索引顺序表

分成多个索引表

## 文件目录

目录表就是目录项的有序集合，也就是一个有结构文件

它记录着文件信息

FCB的有序集合称为"文件目录"，一个FCB就是一个目录项

FCB中包含了文件的基础信息（文件名，物理地址，逻辑结构等）

当我们点击一个文件或者文件夹，系统会根据我们点击的PCB去外存中找对应的文件或者文件夹

### 目录结构

#### 单级目录

就一个根目录，因为只有一个目录，所以文件都不能重名，创建文件的时候如果重名会阻止创建

不适合多用户系统

#### 二级目录

一个主文件目录，一个用户文件目录

在主文件目录下可以创建多个用户目录，可以实现多用户使用

缺点：不能对文件进行分类

#### 多级目录结构（树级目录结构）

绝对路径，相对路径，当前目录

缺点：树形结构不便于实现文件的共享

#### 无环图目录结构

在树形目录结构的基础上，增加文件共享，允许不同目录，可以引用一个文件

会为每个共享节点设置一个共享节点计时器，当计时器为0的时候才会将节点真正的删除		

### 索引节点（对文件控制块的优化）

在PCB中留下文件名和索引节点的地址

为每个FCB创建对应的索引节点，索引节点包含除文件名外所有的信息

放在磁盘的时候叫 磁盘索引节点

放在内存的时候叫 内存磁盘索引节点

## 文件的物理结构（非空闲空间）

### 文件分配方式

跟内存管理一样，文件也像进程一样在逻辑上被分成不同的块，对应磁盘上的块

#### 连续分配

不仅在逻辑上是连续的块，在磁盘上也被分配在连续的空间

文件系统只需要记录，文件的起始块和最大长度，用户提供逻辑块，系统会判断逻辑块是否超过最大长度，然后用起始块 + 逻辑块找到对应文件

优点：

1. 支持顺序读取和随机读取
2. 在顺序读、写的速度最快

缺点：  

1. 扩展不方便
2. 磁盘利用率低，会产生磁盘碎片，可以使用紧凑技术解决，但代价很大，需要移动很多磁盘块

#### 链接分配—隐式链接

文件块在磁盘上支持离散存储，每个块有一小块空间存储下一个块的指针（类比链表）

优点：

1. 扩展容易
2. 磁盘利用率高

缺点：

1. 读取速度慢	
2. 支持顺序读取与但不支持随机读取，每次查找都需要从第一块开始找

#### 链接分配—显示链接

用文件分配表（FAT）表记录链接文件各物理块的指针。一个磁盘只会建立一个FAT，开机时文件就会被加载到内存，并常驻内存

优点：

1. 方便扩展
2. 读取速度快，支持随机存储，外存利用率高，没有磁盘碎片。

相对于隐式链接来说，地址转换的时候不需要访问磁盘，因此文件的访问效率更高

缺点：

1. 文件分配表FAT需要一定的存储空间

tip：题目中没有明确显示还是隐式，就是隐式、

王琨 我是你一把把  

#### 索引分配

系统为每一个文件创建一个索引表，记录文件对应块的物理位置，存放索引表的物理块叫做索引块，存放文件数据的物理块叫做数据块。

索引表是一个文件创建一个。文件分配表FAT是一个磁盘创建一个

### 索引分配方式存在的问题

索引表太大，一个索引快装不下

#### 链接索引

跟隐式链接一样，将所有索引表用指针链接起来

缺点：如果一个文件有256个索引表，用户要读取第256个索引表里的数据，需要进行256次IO操作，非常低效

#### 多级索引

跟多级页表一样，一级索引表的索引项存着二级索引表的指针

二级索引表，文件的最大长度可以达到256*256*1k

缺点：即使是访问第一个数据块，也需要3次IO访存

#### 混合索引

顶级索引表中有直接地址、一级间接（二级索引表）、二级间接（三级索引表）

读小文件就可以在顶级索引的直接地址找到物理块的位置，两次磁盘IO就可以访问对应的数据块

最大长度就是一共有多少数据块的引用 * 1k

### 超级重要考点

1. 会求多级索引、混合索引的结构计算出文件的最大长度
2. 能分析出访问某个数据块所需要的读磁盘次数（IO次数）

## 文件存储空间管理（空闲空间）

### 存储空间的划分与初始化

#### 空闲表法

适用于连续分配

回收时注意合并空闲区

#### 空闲链表法

1. 空闲盘块链：以块为单位。离散分配、连续分配都适用，为一个文件分配多个盘块时效率最高
2. 空闲盘区链：以区为单位。适用于离散分配，为文件分配多个盘块可能要重复多次操作

#### 位示图法

用0表示空闲，1表示非空闲。一行通常16个

重点考点：能自己推出盘块号与字号行号之间互相转变的公式

#### 成组链接法

类似多级页表， 比每级页表项多个了这一组一共多少块内存

## 文件的基本操作

### 打开文件

会将目录项的信息复制到内存中的打开文件表中

### 读文件

将文件数据从外存读入内存

## 文件共享

### 基于索引节点的共享方式（硬链接）

在索引节点上加一个count计数器，有一个用户链接该文件count加一

有一个用户删除该文件，count减一，只要count不为0，就说明还有用户在使用这个文件，就不能真正的删除该文件

### 基于符号链的共享方式（软链接）

在当前用户下，创建一个文件（Link型的文件）软链接到你的目标文件

类似windows的创建快捷方式，如果目标文件删除，则软链接失效

## 文件保护

### 口令保护

就是访问文件需要输入口令

优点：保存口令的空间开销小，验证口令的时间开销小

缺点：正确的口令存放在系统里，不够安全

### 加密保护

使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密

如使用异或加密

优点：保密性强，不需要再系统中存储密码

缺点：编码解码，或者说加密解密要花费一定时间

### 访问控制

用一个访问控制表记录各个用户或者各组用户对文件的访问权限

实现灵活，可以实现复杂的文件保护功能

## 文件系统的层次结构

### 用户接口

文件系统需要向上层的用户提供一些简单易用的功能接口。这层就是用于处理用户发出的系统调用请求（Read、Write、Open、Close等系统调用）

### 文件目录接口

用户通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的FCB或索引节点。所有和目录、目录项相关的管理工作都在本层完成。如：管理活跃的文件目录表、管理打开文件表等

### 存取控制模块

为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了文件保护相关功能

### 逻辑文件系统与文件信息缓冲区

用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址

### 物理文件系统

这一层需要把上一层提供的文件逻辑地址转换成实际的物理地址

### 服务分配模块 和 设备管理模块

#### 辅助分配模块

负责文件存储空间的管理，即负责分配和回收存储空间

#### 设备管理模块

直接与硬件交互，负责和硬件直接相关的一些管理工作。如：分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等。

## 虚拟文件系统（VFS）

下层有很多文件系统，如磁盘、移动硬盘、U盘。软件发起Open指令，需要根据不同的存储系统发起不同的调用。这就是虚拟文件系统的作用

VFS要求下层的文件必须实现某些规定的函数功能，如open、read、write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求

每打开一个文件，VFS就在主存中新建一个vnode，用同一的数据结构表示文件，无论该文件存储在哪个文件系统

## 磁盘调度算法

### 一次磁盘读、磁盘写操作需要的时间

#### 寻道时间Ts

将磁头移动到指定磁道所画的时间

1. 启动磁头臂：假设耗时s
2. 移动磁头：跨越每个磁道耗时m，总共需要跨越n个磁道

Ts = s + m * n

#### 延迟时间Tr

将磁头定位到指定的扇区

设磁盘的转速为r（单位：转/秒）

平均所需的延迟时间：Tr = 1/2 * 1/r

#### 传输时间Tt

从磁盘读出（写入）所要花费的时间

Tt = 1/r * b/N

#### 总共要花费的时间

T总 = Ts + Tr + Tt

#### tip

延迟时间与传输时间都与转速有关，是硬件决定的

只有寻道时间的操作系统可以决定的

### 磁盘调度算法

#### 先来先服务（FCFS）

按照进程请求访问磁盘的先后顺序进行调度

#### 最短寻找时间算法SSTF

优先处理距离当前磁头最近的磁道，这样可以保证每次寻道的时间都是最短的，跟贪心算法的思想一样，只选择眼前最优，但总体来说不一定是最优的

缺点：可能造成饥饿，一直有磁头附近的请求进入，请求里磁头远的进程就会长时间得不到服务

#### 扫描算法SCAN

磁头只有移动到最边上才能向反方向移动

优点：性能较好，不会产生饥饿

缺点：

1. 只有到达最边上才能改变磁头的移动方向
2. 对于各个位置磁道的响应频率不平均

#### LOOK调度算法

再扫描算法的基础上，增加了在磁头移动的方向上没有请求了，就可以改变磁头方向

#### C-SCAN算法

只有磁头朝某个特定方向移动的时候才处理磁道访问请求，而返回的时候直接快速移动的起始段不处理任何请求

缺点：

1. 只有到达最边上才能改变磁头的移动方向
2. 返回的时候不需要达到最边上，只需要移动到离起始段最边上的磁道请求

#### C-LOOK算法

解决C-SCAN算法的缺点

## 减少磁盘延迟时间的方法

### 交替编号

磁头划过一个扇区，需要一段时间处理这段扇区

磁盘的物理地址是（柱面号、盘面号、扇区号）

可以减少磁盘移动消耗的时间

## 固态硬盘SSD

1. SSD的页对应机械硬盘的扇区
2. SSD的块对应机械硬盘的磁道
3. 想要擦除页的数据，必须以页为单位删除。但是一个块中的其他页的数据就也会被擦除。系统的处理是将页的信息coped导其他快的页中，在讲对对应页中写入数据
4. SSD非常重要的一个缺点，写操作多的话就意味着要多次擦除块，这是对固态硬盘损耗非常大的行为，可能会因此坏掉。机械硬盘不会因为写操作过多而坏掉。
5. SSD的优点：读写速度快，支持随机存储，能耗低，安静无噪音，耐摔抗震，造价贵。
6. 磨损均衡技术
1. 1. 讲“擦除”平均到每个块中，不一直损耗一个块
   2. 动态磨损均衡：将写操作放在磨损程度低的块中
   3. 静态磨损均衡：让磨损严重的块装谢少读多的文件



# 输入输出管理



## I/O设备的概念与分类

### 按信息交换的基本单位

1. 块设备：以块为单位，传输速率快，可寻址
2. 字符设备：已支付为单位，传输速率块，不可寻址，在输入输出是长采用中断驱动方式

## I/O控制器

### 控制器的功能

1.  接收和识别cpu发出指令：有相应的**控制寄存器**，存放相应的命令和参数
2. 向cpu发送设备的状态：会有相应的**状态寄存器**，如：1表示空闲；0表示忙碌
3. 数据交换：输出时，将cpu发送的数据存入数据寄存器；输入时，将设备发送的数据存储数据寄存器
4. 地址识别：类似内存的地址，为了区分设备的各个寄存器。控制器根据cpu发来的“地址”识别cpu想要读写哪个寄存器

### 控制器组成

组成：cpu与控制器的接口、IO逻辑、控制器与设备的接口

#### cpu与控制器的接口

用于实现寄存器与cou之间的通信

拥有很多种类的寄存器，如：数据寄存器、控制寄存器、状态寄存器

#### I/O逻辑

负责cpu接收和识别cpu发来的指令，如地址译码，并负责向设备发送指令

#### 控制器与设备的接口

用于实现控制器与设备进行通信

这个接口会有很多个，一个接口对应的I/O设备

### 内存映像与寄存器独立编址

#### 内存映像

寄存器顺着内存的地址往下排

优点：简化了指令，使用采用对内存进行操作的指令来对寄存器进行控制

#### 寄存器独立编址：

寄存器不顺着内存的地址往下排，而是自己从0开始

缺点：需要设置专门的指令操作寄存器，不仅要指明地址，也要指明寄存器的编号

## IO控制方式

 ### 程序直接控制方式

关键点：不断的轮询

#### 完成一次读写操作的流程

cpu给I/O设备发出读命令，读到I/O设备的状态，如果一直是未就绪，**就会一直读**，直到状态为已就绪，将数据存到寄存器，进而存到存储器

#### CPU干预的频率

很频繁，在等待IO设备完成的过程中不断轮询的向IO设备发出请求

#### 数据传送的单位

字

#### 数据的流向

读操作：I/O > cpu > 内存

写操作：内存 > cpu > I/O

#### 主要的缺点与优点

优点：实现简单，在读写指令之后，加上实现循环检查的一系列指令即可

缺点：cpu利用率低，cpu与io只能串行工作，cpu需要不断轮询检查，一直处于忙等的状态

### 中断驱动方式

关键点：中断

#### 完成一次读写操作的流程

cpu给I/O设备发出读命令，读到I/O设备的状态，如果一直是未就绪，**cpu切换到其他进程，干其他的事**，直到状态为已就绪，**cpu会收到中断指令，然后保存进程的数据与运行环境**，切换回IO进程继续处理IO操作，最后将数据存到寄存器，进而存到存储器。

#### CPU干预的频率

每次I/O操作开始之前、完成之后需要cpu介入

在I/O完成的过程中cpu可以去干别的事

#### 数据传送的单位

字

#### 数据的流向

读操作：IO > cpu > 内存

#### 主要的缺点与优点

优点：解决了程序直接控制的最大问题，不需要一直轮询检查，可以去干其他事，cpu利用率明显增加

缺点：

1. 如果读入大量的字，辉频繁触发中断指令，进而需要频繁的保存恢复其他进程数据与运行环境，浪费cpu大量的时间。
2. 每次读写操作都需要经过cpu

### DMA方式

也叫**直接存储方式**

#### 完成一次读写操作的流程

cpu给I/O设备发出读命令，读到I/O设备的状态，如果一直是未就绪，**cpu切换到其他进程，干其他的事**，直到状态为已就绪，**cpu会收到中断指令，然后保存进程的数据与运行环境**，切换回IO进程继续处理IO操作，最后将数据存到寄存器，进而存到存储器。

#### CPU干预的频率

仅在传送一个或者多个数据块的开始、完成时，才需要cpu的介入

#### 数据传送的单位

数据块（注意：每次读取的只能是连续的多个块，如果是离散的就需要cpu多次干预）

#### 数据的流向

读操作：I/O > 内存

写操作：内存 > I/O

#### 主要的缺点与优点

优点：

1. 解决了会出现大量中断指令，浪费cpu大量时间的问题
2. 从IO设备直接存储到存储，不需要经转cpu

缺点：

1. 只能操作连续的数据块，对于离散的数据块需要cpu频繁的参与



### 通道控制方式

通道：一种硬件，可以理解成**弱鸡版的cpu**，能处理指令很单一，并且通道程序放在内存中，与cpu 共享一个内存

#### 完成一次读写操作的流程

cpu给I/O设备发出读命令，读到I/O设备的状态，如果一直是未就绪，**cpu切换到其他进程，干其他的事**，直到状态为已就绪，**cpu会收到中断指令，然后保存进程的数据与运行环境**，切换回IO进程继续处理IO操作，最后将数据存到寄存器，进而存到存储器。

#### CPU干预的频率

极低，通道会根据cpu的指示执行相应的通道程序，只有完成一组数据块的读写才需要发出中断信号，请求cpu干预

#### 数据传送的单位

一组数据块，可以是离散的

#### 数据的流向

读操作：I/O > 内存

写操作：内存 > I/O

#### 主要的缺点与优点

优点：

1. cpu、通道、io设备并行工作，资源利用率很高

缺点：

1. 实现复杂，需要专门的通道硬件的支持

## I/O软件层次结构

理解I/O各个层次之间的顺序，要能推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立性软件、设备驱动程序这两层）。

只需理解一个特点即可：直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；没有设计硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的

![image-20231022155550376](C:\Users\wangkun\AppData\Roaming\Typora\typora-user-images\image-20231022155550376.png)























